// Generated by CoffeeScript 1.8.0
(function() {
  var HEIGHT, WIDTH, addAttribute, createProgram, createVBO, draw, fragmentShaderSource, loadShader, vertexColor, vertexPosition, vertexShaderSource;

  WIDTH = 500;

  HEIGHT = 300;

  vertexShaderSource = "attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nvarying   vec4 vColor;\n\nvoid main(void){\n    vColor = color;\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}";

  fragmentShaderSource = "precision mediump float;\nvarying vec4 vColor;\nvoid main(void){\n    gl_FragColor = vColor;\n}";

  vertexPosition = new Float32Array([0.0, 1.0, 1.0, 1.0, 0.0, 1.0, -1.0, 0.0, 1.0]);

  vertexColor = new Float32Array([1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0]);

  loadShader = function(gl, type, source) {
    var shader;
    shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(shader));
    }
    return shader;
  };

  createProgram = function(gl, vs, fs) {
    var program;
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    return program;
  };

  createVBO = function(gl, data) {
    var vbo;
    vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vbo;
  };

  addAttribute = function(gl, program, vbo, name, argsCount, type) {
    var attr;
    if (type == null) {
      type = gl.FLOAT;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    attr = gl.getAttribLocation(program, name);
    gl.enableVertexAttribArray(attr);
    return gl.vertexAttribPointer(attr, argsCount, type, false, 0, 0);
  };

  draw = function(gl, locationUniform, mvpMatrix) {
    gl.uniformMatrix4fv(locationUniform, false, mvpMatrix);
    return gl.drawArrays(gl.TRIANGLES, 0, 3);
  };

  window.addEventListener('load', function() {
    var canvas, colorVBO, fragmentShader, gl, locationUniform, m, mMatrix, mvpMatrix, pMatrix, positionVBO, program, tmpMatrix, vMatrix, vertexShader;
    canvas = document.createElement('canvas');
    document.body.appendChild(canvas);
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    gl = canvas.getContext('webgl');
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    program = createProgram(gl, vertexShader, fragmentShader);
    locationUniform = gl.getUniformLocation(program, 'mvpMatrix');
    positionVBO = createVBO(gl, vertexPosition);
    addAttribute(gl, program, positionVBO, 'position', 3);
    colorVBO = createVBO(gl, vertexColor);
    addAttribute(gl, program, colorVBO, 'color', 4);
    m = new matIV();
    mMatrix = m.identity(m.create());
    vMatrix = m.identity(m.create());
    pMatrix = m.identity(m.create());
    tmpMatrix = m.identity(m.create());
    mvpMatrix = m.identity(m.create());
    m.lookAt([0.0, 0.0, 3.0], [0, 0, 0], [0, 1, 0], vMatrix);
    m.perspective(90, WIDTH / HEIGHT, 0.1, 100, pMatrix);
    m.multiply(pMatrix, vMatrix, tmpMatrix);
    m.translate(mMatrix, [1.5, 0.0, 0.0], mMatrix);
    m.multiply(tmpMatrix, mMatrix, mvpMatrix);
    draw(gl, locationUniform, mvpMatrix);
    m.identity(mMatrix);
    m.translate(mMatrix, [-1.5, 0.0, 0.0], mMatrix);
    m.multiply(tmpMatrix, mMatrix, mvpMatrix);
    draw(gl, locationUniform, mvpMatrix);
    return gl.flush();
  });

}).call(this);
