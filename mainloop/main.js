// Generated by CoffeeScript 1.8.0
(function() {
  var HEIGHT, WIDTH, addAttribute, count, createProgram, createVBO, draw, fragmentShaderSource, loadShader, m, mMatrix, mvpMatrix, pMatrix, startLoop, tmpMatrix, vMatrix, vertexColor, vertexPosition, vertexShaderSource;

  WIDTH = 500;

  HEIGHT = 300;

  vertexShaderSource = "attribute vec3 position;\nattribute vec4 color;\nuniform   mat4 mvpMatrix;\nvarying   vec4 vColor;\n\nvoid main(void){\n    vColor = color;\n    gl_Position = mvpMatrix * vec4(position, 1.0);\n}";

  fragmentShaderSource = "precision mediump float;\nvarying vec4 vColor;\nvoid main(void){\n    gl_FragColor = vColor;\n}";

  vertexPosition = new Float32Array([0.0, 1.0, 1.0, 1.0, 0.0, 1.0, -1.0, 0.0, 1.0]);

  vertexColor = new Float32Array([1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0]);

  loadShader = function(gl, type, source) {
    var shader;
    shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(shader));
    }
    return shader;
  };

  createProgram = function(gl, vs, fs) {
    var program;
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    return program;
  };

  createVBO = function(gl, data) {
    var vbo;
    vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vbo;
  };

  addAttribute = function(gl, program, vbo, name, argsCount, type) {
    var attr;
    if (type == null) {
      type = gl.FLOAT;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    attr = gl.getAttribLocation(program, name);
    gl.enableVertexAttribArray(attr);
    return gl.vertexAttribPointer(attr, argsCount, type, false, 0, 0);
  };

  draw = function(gl, locationUniform, mvpMatrix) {
    gl.uniformMatrix4fv(locationUniform, false, mvpMatrix);
    return gl.drawArrays(gl.TRIANGLES, 0, 3);
  };

  count = 0;

  m = new matIV();

  mMatrix = m.identity(m.create());

  vMatrix = m.identity(m.create());

  pMatrix = m.identity(m.create());

  tmpMatrix = m.identity(m.create());

  mvpMatrix = m.identity(m.create());

  m.lookAt([0.0, 0.0, 3.0], [0, 0, 0], [0, 1, 0], vMatrix);

  m.perspective(90, WIDTH / HEIGHT, 0.1, 100, pMatrix);

  m.multiply(pMatrix, vMatrix, tmpMatrix);

  startLoop = function(gl) {
    var colorVBO, fragmentShader, locationUniform, positionVBO, program, update, vertexShader;
    vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    program = createProgram(gl, vertexShader, fragmentShader);
    locationUniform = gl.getUniformLocation(program, 'mvpMatrix');
    positionVBO = createVBO(gl, vertexPosition);
    addAttribute(gl, program, positionVBO, 'position', 3);
    colorVBO = createVBO(gl, vertexColor);
    addAttribute(gl, program, colorVBO, 'color', 4);
    return (update = function() {
      var rad, scaleRate, x, y;
      count++;
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      rad = (count % 360) * Math.PI / 180;
      x = Math.cos(rad);
      y = Math.sin(rad);
      m.identity(mMatrix);
      m.translate(mMatrix, [x, y, 0.0], mMatrix);
      m.multiply(tmpMatrix, mMatrix, mvpMatrix);
      draw(gl, locationUniform, mvpMatrix);
      x = Math.sin(rad);
      y = Math.cos(rad);
      scaleRate = Math.sin(rad);
      m.identity(mMatrix);
      m.translate(mMatrix, [x - 1.5, y, 0.0], mMatrix);
      m.scale(mMatrix, [scaleRate, scaleRate, 0.0], mMatrix);
      m.multiply(tmpMatrix, mMatrix, mvpMatrix);
      draw(gl, locationUniform, mvpMatrix);
      gl.flush();
      return requestAnimationFrame(update);
    })();
  };

  window.addEventListener('load', function() {
    var canvas, gl;
    canvas = document.createElement('canvas');
    document.body.appendChild(canvas);
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    gl = canvas.getContext('webgl');
    return startLoop(gl);
  });

}).call(this);
